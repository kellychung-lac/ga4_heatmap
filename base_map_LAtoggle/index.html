<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>California Cities Heatmap</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Leaflet -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- Gzip + TopoJSON -->
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>

    <!-- Chroma.js for color scales -->
    <script src="https://cdn.jsdelivr.net/npm/chroma-js@2.4.2/chroma.min.js"></script>

    <style>
      html, body, #map { height: 100%; margin: 0; }
      .control-card {
        background: #fff; padding: 8px 10px; font: 12px/1.2 Arial, sans-serif;
        box-shadow: 0 1px 4px rgba(0,0,0,.2);
      }
      .control-card h4 { margin: 4px 0 6px; font-size: 12px; }
      .control-card label { display: block; cursor: pointer; margin: 2px 0; }
      .city-label {
        font-weight: 600; font-size: 12px; white-space: nowrap;
        text-shadow: 0 1px 2px rgba(255,255,255,.9);
      }
    </style>
  </head>
  <body>
    <div id="map"></div>

    <script>
      // ---------- utils ----------
      async function fetchGzipJSON(url) {
        const r = await fetch(url);
        if (!r.ok) throw new Error(`Fetch ${url}: ${r.status}`);
        const ab = await r.arrayBuffer();
        const txt = pako.ungzip(new Uint8Array(ab), { to: "string" });
        return JSON.parse(txt);
      }
      async function fetchGzipGeoOrTopoAsGeoJSON(url) {
        const obj = await fetchGzipJSON(url);
        if (obj && obj.type === "Topology") {
          const key = Object.keys(obj.objects)[0];
          return topojson.feature(obj, obj.objects[key]);
        }
        return obj;
      }
      function detectCityProp(feature) {
        const props = feature?.properties || {};
        const cands = ["CITY","City","city","NAME","Name","name","PLACENAME","PLACENAM"];
        for (const k of cands) if (k in props) return k;
        const keys = Object.keys(props);
        return keys.length ? keys[0] : "CITY";
      }
      // Normalize strings for robust matching (case, spaces, punctuation)
      function norm(s) {
        return String(s || "")
          .toLowerCase()
          .normalize("NFKD")
          .replace(/[\u0300-\u036f]/g, "")   // accents
          .replace(/city of /g, "")          // drop 'city of'
          .replace(/[\s\.-]/g, "")           // spaces, dots, hyphens
          .replace(/[^a-z]/g, "");           // keep letters
      }

      // ---------- state ----------
      const LA_CANON = "losangeles"; // normalized target
      const state = {
        campaign: "ALL",
        metric: "Clicks",      // Clicks | CTR | Conversions
        includeLA: true,
        metrics: null,
        cityProp: null,
        map: null,
        fillLayer: null,
        labelLayer: null,
        // per-campaign parallel domain sets
        scales_include: null,
        scales_exclude: null,
        // detected keys/names
        laMetricsKey: null,     // the exact key in metrics (per campaign)
        laGeoNames: new Set(),  // any GeoJSON names that map to LA
      };

      // ---------- domains ----------
      function boundsJS(vals) {
        const s = vals.filter((v) => Number.isFinite(v));
        if (!s.length) return [0, 1];
        let lo = Math.min(...s), hi = Math.max(...s);
        if (lo === hi) hi = lo + 1e-9;
        return [lo, hi];
      }
      function campaignDomains(includeLA, campaign) {
        const bag = { clicks: [], conversions: [], ctr: [] };
        const cities = state.metrics.data[campaign] || {};
        for (const [city, rec] of Object.entries(cities)) {
          const isLA = norm(city) === LA_CANON || city === state.laMetricsKey;
          if (!includeLA && isLA) continue;
          if (Number.isFinite(rec?.val_clicks_color))      bag.clicks.push(rec.val_clicks_color);
          if (Number.isFinite(rec?.val_conversions_color)) bag.conversions.push(rec.val_conversions_color);
          if (Number.isFinite(rec?.val_ctr_color))         bag.ctr.push(rec.val_ctr_color);
        }
        return {
          clicks: boundsJS(bag.clicks),
          conversions: boundsJS(bag.conversions),
          ctr: boundsJS(bag.ctr),
        };
      }
      function refreshScalesAndLAKey() {
        // detect the LA key present in this campaign's metrics
        const cities = Object.keys(state.metrics.data[state.campaign] || {});
        const exact = cities.find(c => norm(c) === LA_CANON);
        // fallback: contains "losangeles" somewhere (handles weird tokens)
        const fuzzy = cities.find(c => norm(c).includes(LA_CANON));
        state.laMetricsKey = exact || fuzzy || null;

        // compute domains include/exclude LA for current campaign
        state.scales_include = campaignDomains(true,  state.campaign);
        state.scales_exclude = campaignDomains(false, state.campaign);

        console.log("LA metrics key:", state.laMetricsKey || "(not found)");
        console.log("Active domains",
          state.includeLA ? "(Include LA)" : "(Exclude LA)",
          state.metric,
          state.includeLA ? state.scales_include : state.scales_exclude
        );
      }
      function getActiveScales() {
        return state.includeLA ? state.scales_include : state.scales_exclude;
      }
      function getScale(metric) {
        const scales = getActiveScales();
        const [min, max] =
          metric === "CTR" ? scales.ctr :
          metric === "Clicks" ? scales.clicks : scales.conversions;
        const scale = chroma.scale(["#f7fbff", "#08306b"]).domain([min, max]);
        return (v) => (Number.isFinite(v) ? scale(v).hex() : "#d3d3d3");
      }

      // ---------- map styling & tooltips ----------
      function formatValue(rec) {
        if (!rec) return "—";
        if (state.metric === "CTR")
          return Number.isFinite(rec.val_ctr) ? (rec.val_ctr * 100).toFixed(2) + "%" : "—";
        if (state.metric === "Clicks")
          return Number.isFinite(rec.val_clicks) ? Math.round(rec.val_clicks).toLocaleString() : "—";
        return Number.isFinite(rec.val_conversions)
          ? Math.round(rec.val_conversions).toLocaleString()
          : "—";
      }
      function isLAName(name) {
        // match against normalized name and any discovered GeoJSON variants
        return norm(name) === LA_CANON || state.laGeoNames.has(name);
      }
      function styleFeature(feat) {
        const city = feat.properties[state.cityProp];
        const rec = (state.metrics.data[state.campaign] || {})[city] || null;

        if (!state.includeLA && isLAName(city)) {
          return {
            color: "#444", weight: 1.2, dashArray: "4,3",
            fillColor: "#ffffff", fillOpacity: 0.0
          };
        }

        let cv = null;
        if (state.metric === "Clicks") cv = rec?.val_clicks_color;
        else if (state.metric === "CTR") cv = rec?.val_ctr_color;
        else cv = rec?.val_conversions_color;

        const fill = getScale(state.metric)(cv);
        return {
          color: "#000", weight: 0.4,
          fillColor: fill, fillOpacity: Number.isFinite(cv) ? 0.75 : 0.25,
        };
      }
      function onEachFeature(feat, layer) {
        const city = feat.properties[state.cityProp];
        const rec  = (state.metrics.data[state.campaign] || {})[city] || null;

        // record any GeoJSON variant that looks like LA (for styling later)
        if (norm(city) === LA_CANON) state.laGeoNames.add(city);

        if (!state.includeLA && isLAName(city)) {
          layer.bindTooltip(
            `<b>${city}</b><br>${state.metric}: ${formatValue(rec)}<br><i>(excluded from color scale)</i>`,
            { sticky: true, direction: "auto" }
          );
          return;
        }
        layer.bindTooltip(
          `<b>${city}</b><br>${state.metric}: ${formatValue(rec)}`,
          { sticky: true, direction: "auto" }
        );
      }
      function rebuildChoropleth() {
        if (!state.fillLayer) return;
        state.fillLayer.setStyle(styleFeature);
        state.fillLayer.eachLayer((l) => onEachFeature(l.feature, l));
        // log current min/max so you can see the change on toggle
        const s = getActiveScales();
        const mm = state.metric === "CTR" ? s.ctr : state.metric === "Clicks" ? s.clicks : s.conversions;
        console.log("Domain", state.metric, state.includeLA ? "(Include LA)" : "(Exclude LA)", mm);
      }

      // ---------- controls ----------
      function makeRadioControl() {
        const Control = L.Control.extend({
          options: { position: "topright" },
          onAdd: function () {
            const div = L.DomUtil.create("div", "control-card leaflet-bar");
            div.innerHTML = `
              <h4>Campaign</h4>
              ${["ALL","Display","Search"].map(c =>
                `<label><input type="radio" name="camp" value="${c}" ${c===state.campaign?"checked":""}/> ${c}</label>`
              ).join("")}
              <hr/>
              <h4>Metric</h4>
              ${["Clicks","CTR","Conversions"].map(m =>
                `<label><input type="radio" name="metric" value="${m}" ${m===state.metric?"checked":""}/> ${m}</label>`
              ).join("")}
              <hr/>
              <h4>Los Angeles</h4>
              ${[
                {label:"Include", val:"include", checked: state.includeLA},
                {label:"Exclude", val:"exclude", checked: !state.includeLA}
              ].map(o =>
                `<label><input type="radio" name="laMode" value="${o.val}" ${o.checked?"checked":""}/> ${o.label}</label>`
              ).join("")}
            `;
            div.addEventListener("change", (e) => {
              if (e.target.name === "camp") {
                state.campaign = e.target.value;
                refreshScalesAndLAKey();
                rebuildChoropleth();
                updateLabels();
              }
              if (e.target.name === "metric") {
                state.metric = e.target.value;
                rebuildChoropleth();
                updateLabels();
              }
              if (e.target.name === "laMode") {
                state.includeLA = e.target.value === "include";
                // domains depend on include/exclude
                refreshScalesAndLAKey();
                rebuildChoropleth();
              }
            });
            L.DomEvent.disableClickPropagation(div);
            L.DomEvent.disableScrollPropagation(div);
            return div;
          },
        });
        return new Control();
      }

      // ---------- labels ----------
      let labelData = null;
      function clearLabels() {
        if (state.labelLayer) { state.map.removeLayer(state.labelLayer); state.labelLayer = null; }
      }
      function updateLabels() {
        if (!labelData) return;
        clearLabels();
        const markers = labelData.map((pt) =>
          L.marker([pt.lat, pt.lon], {
            icon: L.divIcon({ className: "", html: `<div class="city-label">${pt.city}</div>` }),
            interactive: false,
          })
        );
        state.labelLayer = L.layerGroup(markers).addTo(state.map);
        function toggleByZoom() {
          const z = state.map.getZoom();
          state.labelLayer.getLayers().forEach(
            (m) => (m.getElement().style.display = z >= 7 ? "block" : "none")
          );
        }
        toggleByZoom();
        state.map.off("zoomend", toggleByZoom);
        state.map.on("zoomend", toggleByZoom);
      }

      // ---------- boot ----------
      (async function main() {
        state.map = L.map("map").setView([36.7783, -119.4179], 6);
        L.tileLayer(
          "https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}.png",
          { attribution: "&copy; OpenStreetMap contributors & Carto", maxZoom: 18 }
        ).addTo(state.map);

        state.metrics = await fetchGzipJSON("./data/city_metrics.json.gz");

        const geo = await fetchGzipGeoOrTopoAsGeoJSON("./data/regions.geojson.gz");
        state.cityProp = detectCityProp(geo.features[0]);

        // seed LA GeoJSON names set
        geo.features.forEach(f => {
          const nm = f.properties[state.cityProp];
          if (norm(nm) === LA_CANON) state.laGeoNames.add(nm);
        });

        state.fillLayer = L.geoJSON(geo, { style: styleFeature, onEachFeature }).addTo(state.map);

        labelData = await fetchGzipJSON("./data/city_labels.json.gz");
        updateLabels();

        // compute domains + detect LA key for initial campaign
        refreshScalesAndLAKey();
        state.map.addControl(makeRadioControl());
        rebuildChoropleth();
      })().catch((err) => {
        console.error(err);
        alert(err.message);
      });
    </script>
  </body>
</html>

